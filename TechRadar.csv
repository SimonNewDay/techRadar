name,ring,quadrant,isNew,description
Design systems,Adopt,Techniques,TRUE,"<p>As application development becomes increasingly dynamic and complex, it's a challenge to deliver accessible and usable products with consistent style. This is particularly true in larger organizations with multiple teams working on different products. <strong>Design systems</strong> define a collection of design patterns, component libraries and good design and engineering practices that ensure consistent digital products. Built on the corporate style guides of the past, design systems offer shared libraries and documents that are easy to find and use. Generally, guidance is written down as code and kept under version control so that the guide is less ambiguous and easier to maintain than simple documents. Design systems have become a standard approach when working across teams and disciplines in product development because they allow teams to focus. They can address strategic challenges around the product itself without reinventing the wheel every time a new visual component is needed.</p>"
Platform engineering product teams,Adopt,Techniques,TRUE,"<p>As noted in one of the themes for this edition, the industry is increasingly gaining experience with <strong>platform engineering product teams</strong> that create and support internal platforms. These platforms are used by teams across an organization and accelerate application development, reduce operational complexity and improve time to market. With increasing adoption we're also clearer on both good and bad patterns for this approach. When creating a platform, it’s critical to have clearly defined customers and products that will benefit from it rather than building in a vacuum. We caution against <a href=""/radar/techniques/layered-platform-teams"">layered platform teams</a> that simply preserve existing technology silos but apply the ""platform team"" label as well as against ticket-driven platform operating models. We're still big fans of using concepts from <a href=""https://teamtopologies.com/"">Team Topologies</a> as we think about how best to organize platform teams. We consider platform engineering product teams to be a standard approach and a significant enabler for high-performing IT.</p>"
UI/BFF shared types,Assess,Techniques,TRUE,"<p>With <a href=""/radar/languages-and-frameworks/typescript"">TypeScript</a> becoming a common language for front-end development and <a href=""/radar/platforms/node-js"">Node.js</a> becoming the preferred <a href=""/radar/techniques/bff-backend-for-frontends"">BFF</a> technology, we're seeing increasing use of <strong>UI/BFF shared types</strong>. In this technique, a single set of type definitions is used to define both the data objects returned by front-end queries and the data served to satisfy those queries by the back-end server. Ordinarily, we would be cautious about this practice because of the unnecessarily tight coupling it creates across process boundaries. However, many teams are finding that the benefits of this approach outweigh any risks of tight coupling. Since the BFF pattern works best when the same team owns both the UI code and the BFF, often storing both components in the same repository, the UI/BFF pair can be viewed as a single cohesive system. When the BFF offers strongly typed queries, the results can be tailored to the specific needs of the frontend rather than reusing a single, general-purpose entity that must serve the needs of many consumers and contain more fields than actually required. This reduces the risk of accidentally exposing data that the user shouldn't see, prevents incorrect interpretation of the returned data object and makes the query more expressive. This practice is particularly useful when implemented with <a href=""/radar/languages-and-frameworks/io-ts"">io-ts</a> to enforce the run-time type safety.</p>"
Bounded low-code platforms,Assess,Techniques,TRUE,"<p>One of the most nuanced decisions facing companies at the moment is the adoption of low-code or no-code platforms, that is, platforms that solve very specific problems in very limited domains. Many vendors are pushing aggressively into this space. The problems we see with these platforms typically relate to an inability to apply good engineering practices such as versioning. Testing too is typically really hard. However, we noticed some interesting new entrants to the market — including <a href=""https://www.honeycode.aws/"">Amazon Honeycode</a>, which makes it easy to create simple task or event management apps, and <a href=""https://parabola.io/"">Parabola</a> for IFTTT-like cloud workflows — which is why we're once again including <strong>bounded low-code platforms</strong> in this volume. Nevertheless, we remain deeply skeptical about their wider applicability since these tools, like Japanese Knotweed, have a knack of escaping their bounds and tangling everything together. That's why we still strongly advise caution in their adoption.</p>"
Import maps for micro frontends,Assess,Techniques,TRUE,"<p>When composing an application out of several <a href=""/radar/techniques/micro-frontends"">micro frontends</a>, some part of the system needs to decide which micro frontends to load and where to load them from. So far, we've either built custom solutions or relied on a broader framework like <a href=""/radar/languages-and-frameworks/single-spa"">single-spa</a>. Now there is a new standard, <a href=""https://github.com/WICG/import-maps"">import maps</a>, that helps in both cases. Our first experiences show that using <strong>import maps for micro frontends</strong> allows for a neat separation of concerns. The JavaScript code states what to import and a small script tag in the initial HTML response specifies where to load the frontends from. That HTML is obviously generated on the server side, which makes it possible to use some dynamic configuration during its rendering. In many ways this technique reminds us of linker/loader paths for dynamic Unix libraries. At the moment import maps are only supported by Chrome, but with the <a href=""https://github.com/systemjs/systemjs"">SystemJS</a> polyfill they're ready for wider use.</p>"
Privacy-focused web analytics,Assess,Techniques,TRUE,"<p><strong>Privacy-focused web analytics</strong> is a technique for gathering web analytics without compromising end user privacy by keeping the end users truly anonymous. One surprising consequence of General Data Protection Regulation (GDPR) compliance is the decision taken by many organizations to degrade the user experience with complex cookie consent processes, especially when the user doesn't immediately consent to the ""all the cookies"" default settings. Privacy-focused web analytics has the dual benefit of both observing the spirit and letter of GDPR while also avoiding the need to introduce intrusive cookie consent forms. One implementation of this approach is <a href=""https://plausible.io/"">Plausible</a>.</p>"
Remote mob programming,Assess,Techniques,TRUE,"<p>Mob programming is one of those techniques that our teams have found to be easier when done remotely. <strong>Remote mob programming</strong> is allowing teams to quickly ""mob"" around an issue or piece of code without the physical constraints of only being able to fit so many people around a pairing station. Teams can quickly collaborate on an issue or piece of code without having to connect to a big display, book a physical meeting room or find a whiteboard.</p>"
Naive password complexity requirements,Hold,Techniques,TRUE,"<p>Password policies are a standard default for many organizations today. However, we're still seeing organizations requiring passwords to include a variety of symbols, numbers, uppercase and lowercase letters as well as inclusion of special characters. These are <strong>naive password complexity requirements</strong> that lead to a false sense of security as users will opt for more insecure passwords because the alternative is difficult to remember and type. According to <a href=""https://pages.nist.gov/800-63-3/sp800-63b.html"">NIST recommendations</a>, the primary factor in password strength is password length, and therefore users should choose long passphrases with a maximum requirement of 64 characters (including spaces). These passphrases are more secure and memorable.</p>"
Peer review equals pull request,Hold,Techniques,TRUE,"<p>Some organizations seem to think <strong>peer review equals pull request</strong>; they've taken the view that the only way to achieve a peer review of code is via a pull request. We've seen this approach create significant team bottlenecks as well as significantly degrade the quality of feedback as overloaded reviewers begin to simply reject requests. Although the argument could be made that this is one way to demonstrate code review ""regulatory compliance"" one of our clients was told this was invalid since there was no evidence the code was actually read by anyone prior to acceptance. Pull requests are only one way to manage the code review workflow; we urge people to consider other approaches, especially where there is a need to coach and pass on feedback carefully.</p>"
Separate code and pipeline ownership,Hold,Techniques,TRUE,"<p>Ideally, but especially when teams are practicing DevOps, the deployment pipeline and the code being deployed should be owned by the same team. Unfortunately, we still see organizations where there is <strong>separate code and pipeline ownership</strong>, with the deployment pipeline configuration owned by the infrastructure team; this results in delays to changes, barriers to improvements and a lack of development team ownership and involvement in deployments. One cause of this can clearly be the separate team, another can be the desire to retain “gatekeeper” processes and roles. Although there can be legitimate reasons for using this approach (e.g., regulatory control), in general we find it painful and unhelpful.</p>"
Variable fonts,Assess,Platforms,TRUE,"<p><strong>Variable fonts</strong> are a way of avoiding the need to find and include separate font files for different weights and styles. Everything is in one font file, and you can use properties to select which style and weight you need. While not new, we still see sites and projects that could benefit from this simple approach. If you have pages that are including many variations of the same font, we suggest trying out variable fonts.</p>"
Bit.dev,Assess,Platforms,TRUE,"<p><strong><a href=""https://bit.dev/"">Bit.dev</a></strong> is a cloud-hosted collaborative platform for UI components extracted, modularized and reused with <a href=""https://github.com/teambit/bit"">Bit</a>. <a href=""/radar/platforms/web-components-standard"">Web components</a> have been around for a while, but building a modern front-end application by assembling small, independent components extracted from other projects has never been easy. Bit was designed to let you do exactly that: extract a component from an existing library or project. You can either build your own service on top of Bit for component collaboration or use Bit.dev.</p>"
Sentry,Adopt,Tools,TRUE,"<p><strong><a href=""https://sentry.io/"">Sentry</a></strong> has become the default choice for many of our teams when it comes to front-end error reporting. The convenience of features like the grouping of errors or defining patterns for discarding errors with certain parameters helps deal with the flood of errors coming from many end user devices. Integrating Sentry in your CD pipeline allows you to upload source maps for more efficient error debugging, and it helps easily trace back which errors occurred in which version of the software. We also appreciate that while Sentry is primarily a SaaS offering, its source code is publicly available and it can be used for free for smaller use cases and <a href=""https://develop.sentry.dev/self-hosted/"">self-hosting</a>.</p>"
axe-core,Trial,Tools,TRUE,"<p>Making the web inclusive requires serious attention to ensure accessibility is considered <em>and</em> validated at all stages of software delivery. Many of the popular accessibility testing tools are designed for testing after a web application is complete; as a result, issues are detected late and often are harder to fix, accumulating as debt. In our recent internal work on ThoughtWorks websites, we included the open-source accessibility (a11y) testing engine <strong><a href=""https://github.com/dequelabs/axe-core"">axe-core</a></strong> as part of our build processes. It provided team members with early feedback on adherence to accessibility rules, even during early increments. Not every issue can be found through automated inspection, though. Extending the functionality of axe-core is the commercially available <a href=""https://www.deque.com/axe/devtools/"">axe DevTools</a>, including functionality that guides team members through exploratory testing for a majority of accessibility issues.</p>"
esbuild,Trial,Tools,TRUE,"<p>We've always been keen to find tools that can shorten the software development feedback cycle; <strong><a href=""https://github.com/evanw/esbuild"">esbuild</a></strong> is such an example. As the front-end codebase grows larger, we usually face a packaging time of minutes. As a JavaScript bundler optimized for speed, esbuild can reduce this time by a factor of 10 to 100. It is written in Golang and uses a more efficient approach in the process of parsing, printing and source map generation which significantly surpasses build tools such as <a href=""/radar/tools/webpack"">Webpack</a> and <a href=""/radar/tools/parcel"">Parcel</a> in building time. esbuild may not be as comprehensive as those tools in JavaScript syntax transformation; however, this doesn't stop many of our teams from switching to esbuild as their default.</p>"
Playwright,Trial,Tools,TRUE,"<p><strong><a href=""https://playwright.dev/"">Playwright</a></strong> allows you to write Web UI tests for Chromium and Firefox as well as WebKit, all through the same API. The tool has gained some attention for its support of all the major browser engines which it achieves by including patched versions of Firefox and Webkit. We continue to hear positive experience reports with Playwright, in particular its stability. Teams have also found it easy to migrate from <a href=""/radar/languages-and-frameworks/puppeteer"">Puppeteer</a>, which has a very similar API.</p>"
Why Did You Render,Trial,Tools,TRUE,"<p>When working with <a href=""/radar/languages-and-frameworks/react-js"">React</a>, we often encounter situations where our page is very slow because some components are re-rendering when they shouldn't be. <strong><a href=""https://github.com/welldone-software/why-did-you-render"">Why Did You Render</a></strong> is a library that helps detect why a component is re-rendering. It does this by monkey patching React. We've used it in a few of our projects to debug performance issues with great effect.</p>"
GitHub Actions,Assess,Tools,TRUE,"<p>CI servers and build tools are some of the oldest and most widely used in our kit. They run the gamut from simple cloud-hosted services to complex, code-defined pipeline servers that support fleets of build machines. Given our experience and the wide range of options already available, we were initially skeptical when <strong><a href=""https://docs.github.com/en/actions"">GitHub Actions</a></strong> were introduced as another mechanism to manage the build and integration workflow. But the opportunity for developers to start small and easily customize behavior means that GitHub Actions are moving toward the default category for smaller projects. It's hard to argue with the convenience of having the build tool integrated directly into the source code repository. An enthusiastic community has emerged around this feature and that means a wide range of user-contributed tools and workflows are available to get started. Tools vendors are also getting on board via the <a href=""https://github.com/marketplace?type=actions"">GitHub Marketplace</a>. However, we still recommend you proceed with caution. Although code and <a href=""/radar/tools/git"">Git</a> history can be exported into alternative hosts, a development workflow based on GitHub Actions can't. Also, use your best judgment to determine when a project is large or complex enough to warrant an independently supported pipeline tool. But for getting up and running quickly on smaller projects, it's worth considering GitHub Actions and the ecosystem that is growing around them.</p>"
Yelp detect-secrets,Assess,Tools,TRUE,"<p><strong><a href=""https://github.com/Yelp/detect-secrets"">Yelp detect-secrets</a></strong> is a Python module for detecting secrets within a codebase; it scans files within a directory looking for secrets. It can be used as a <a href=""/radar/tools/git"">Git</a> pre-commit hook or to perform a scan in multiple places within the CI/CD pipeline. It comes with a default configuration that makes it very easy to use but can be modified to suit your needs. You can also install custom plugins to add to its default heuristic searches. Compared to similar offerings, we found that this tool detects more types of secrets with its out-of-the-box configuration.</p>"
io-ts,Trial,languages-and-frameworks,TRUE,"<p>We've really enjoyed using <a href=""/radar/languages-and-frameworks/typescript"">TypeScript</a> for a while now and love the safety that the strong typing provides. However, getting data into the bounds of the type system — from, for example, a call to a back-end service — can lead to run-time errors. One library that helps solve this problem is <strong><a href=""https://gcanti.github.io/io-ts/"">io-ts</a></strong>. It bridges the gap between compile-time type-checking and run-time consumption of external data by providing encode and decode functions. It can also be used as a custom type guard. As we gain more experience with io-ts in our work, our initially positive impressions are confirmed, and we still like the elegance of its approach.</p>"
Remix,Trial,languages-and-frameworks,TRUE,""
Next.js,Trial,languages-and-frameworks,TRUE,"<p>We've had a bit more experience using <strong><a href=""https://nextjs.org/"">Next.js</a></strong> for <a href=""/radar/languages-and-frameworks/react-js"">React</a> codebases since the last time we wrote about it. Next.js is an opinionated, zero-configuration framework that includes simplified routing, automatic compilation and bundling with <a href=""/radar/tools/webpack"">Webpack</a> and <a href=""/radar/tools/babel"">Babel</a>, fast hot reloading for a convenient developer workflow among other features. It provides server-side rendering by default, improves search engine optimization and the initial load time and supports incremental static generation. We've had positive experience reports from teams using Next.js and, given its large community, continue to be excited about the evolution of the framework.</p>"
Jotai and Zustand,Assess,languages-and-frameworks,TRUE,"<p>In the previous Radar, we commented on the beginning of a phase of experimentation with state management in <a href=""/radar/languages-and-frameworks/react-js"">React</a> applications. We moved <a href=""/radar/languages-and-frameworks/redux"">Redux</a> back into the Trial ring, documenting that it is no longer our default choice, and we mentioned Facebook's <a href=""/radar/languages-and-frameworks/recoil"">Recoil</a>. In this volume we want to highlight <strong><a href=""https://github.com/pmndrs/jotai"">Jotai</a> and <a href=""https://github.com/pmndrs/zustand"">Zustand</a></strong>: Both are state management libraries for React; both aim to be small and simple to use; and, perhaps not by complete coincidence, both names are translations of the word <em>state</em> into Japanese and German, respectively. Beyond these similarities, however, they differ in their design. Jotai's design is closer to that of Recoil in that state consists of atoms stored within the React component tree, whereas Zustand stores the state outside of React in a single state object, much like the approach taken by Redux. The authors of Jotai provide a helpful <a href=""https://github.com/pmndrs/jotai/blob/master/docs/introduction/comparison.md"">checklist</a> to decide when to use which.</p>"
React Hook Form,Assess,languages-and-frameworks,TRUE,"<p>Building forms for the web remains one of the perennial challenges of front-end development, in particular with <a href=""/radar/languages-and-frameworks/react-js"">React</a>. Many of our teams working with React have been using <a href=""/radar/languages-and-frameworks/formik"">Formik</a> to make this easier, but some are now assessing <strong><a href=""https://react-hook-form.com/"">React Hook Form</a></strong> as a potential alternative. <a href=""/radar/languages-and-frameworks/react-hooks"">React Hooks</a> already existed when React Hook Form was created, so it could use them as a first-class concept: the framework is registering and tracking form elements as uncontrolled components via a hook, thereby significantly reducing the need for re-rendering. It's also quite lightweight in size and in the amount of boilerplate code needed.</p>"
Webpack 5 Module Federation,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Formik,Assess,languages-and-frameworks,TRUE,""
C#,Hold,languages-and-frameworks,TRUE,""
Yup,Assess,languages-and-frameworks,TRUE,""
Angular,Hold,languages-and-frameworks,TRUE,""
Gatsby,Hold,languages-and-frameworks,TRUE,""
Umbraco,Hold,languages-and-frameworks,TRUE,""
Pa11y,Assess,Tools,TRUE,""
Lighthouse,Assess,Tools,TRUE,""
